name: CI/CD & Deployment Check

# D√©clencheurs : Pushes sur les branches principales et toutes les Pull Requests
on:
  push:
    branches: [ "main", "dev_v5" ]
  pull_request:
    branches: [ "main", "dev_v5" ]

jobs:
  # ------------------------------------------------------------------
  # JOB 1 : Tests Unitaires & Qualit√© du Code (Environnement L√©ger)
  # ------------------------------------------------------------------
  unit-tests:
    name: üß™ Unit Tests (Local/SQLite)
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip' # Cache automatique des paquets pip

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # Installation des d√©pendances de dev (tests, linting) si pr√©sentes
          if [ -f deployment/dev/requirements.txt ]; then pip install -r deployment/dev/requirements.txt; fi

      - name: Configure Environment (Local)
        # On simule le fichier .env.local comme d√©crit dans docs/deployment/dev/dev.md
        run: |
          echo "DJANGO_SETTINGS_MODULE=config.django.dev.local" > .env
          echo "SECRET_KEY=django-insecure-ci-test-key-replace-me" >> .env
          echo "EXPOSITION_PORT=8000" >> .env
          echo "ALLOWED_HOSTS=localhost,127.0.0.1" >> .env
          # Pas de config DB MySQL ici => Django fallback sur SQLite automatiquement

      - name: Run Migrations (Check Integrity)
        run: |
          python manage.py makemigrations --check --dry-run
          python manage.py migrate

      - name: Run Tests
        run: |
          python manage.py test

  # ------------------------------------------------------------------
  # JOB 2 : Simulation de D√©ploiement Docker (Production-like)
  # ------------------------------------------------------------------
  docker-deployment-check:
    name: üê≥ Docker Build & Smoke Test
    runs-on: ubuntu-latest
    needs: unit-tests # N'ex√©cute ce job que si les tests unitaires passent
    timeout-minutes: 15

    services:
      # On pourrait d√©finir MariaDB ici, mais on utilise votre docker-compose pour tester la stack compl√®te
      # C'est plus fid√®le √† votre processus "make dev-run" ou d√©ploiement prod.

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Create .env for Docker
        # Cr√©ation d'un .env complet pour Docker (bas√© sur docs/deployment/dev/dev_unix.md)
        run: |
          echo "DJANGO_SETTINGS_MODULE=config.django.prod.prod" > .env
          echo "SECRET_KEY=prod-ci-secret-key-xyz" >> .env
          echo "EXPOSITION_PORT=8000" >> .env
          echo "ALLOWED_HOSTS=localhost,127.0.0.1,api.pod.test" >> .env
          
          # Database Config (doit correspondre au docker-compose)
          echo "MYSQL_DATABASE=pod_db" >> .env
          echo "MYSQL_USER=pod_user" >> .env
          echo "MYSQL_PASSWORD=pod_password" >> .env
          echo "MYSQL_ROOT_PASSWORD=root_password" >> .env
          echo "MYSQL_HOST=db" >> .env
          echo "MYSQL_PORT=3306" >> .env

      - name: Build & Start Containers
        # On tente d'utiliser le compose de PROD en priorit√©, sinon DEV
        run: |
          if [ -f deployment/prod/docker-compose.yml ]; then
            echo "üöÄ Starting Production Stack..."
            docker compose -f deployment/prod/docker-compose.yml up -d --build
          else
            echo "‚ö†Ô∏è Prod compose missing, falling back to Dev Stack..."
            docker compose -f deployment/dev/docker-compose.yml up -d --build
          fi

      - name: Wait for Container Health
        run: |
          echo "‚è≥ Waiting for services to be ready..."
          sleep 15
          docker compose -f deployment/dev/docker-compose.yml ps
          docker compose -f deployment/dev/docker-compose.yml logs api --tail 50

      - name: Smoke Test (Verify API is Alive)
        # Teste si Swagger (ou l'accueil) r√©pond. R√©essaie pendant 60s max.
        run: |
          echo "üîç Checking API availability at http://localhost:8000/api/docs/"
          for i in {1..12}; do
            # On utilise -f pour √©chouer si code HTTP >= 400
            if curl -f http://localhost:8000/api/docs/; then
              echo "‚úÖ Deployment Successful! API is responding."
              exit 0
            fi
            echo "üí§ Waiting for API... ($i/12)"
            sleep 5
          done
          echo "‚ùå API failed to respond in time."
          exit 1